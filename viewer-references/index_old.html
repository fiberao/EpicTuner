<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style type="text/css">
	body { margin: 0; overflow: hidden; }
	#mygraph {
	  position: absolute;
	  width: 100%;
	  height: 100%;
	}
	#control{
		position: absolute;
		z-index: 1;
	}
</style>
  <title>DM VIEW</title>
  	<script src="http://cdn.peerjs.com/0.3/peer.min.js"></script>
	<script src="static/jszip.min.js"></script>
	<script src="static/jszip-utils.min.js"></script>
<!--[if IE]>
	<script src="static/jszip-utils-ie.min.js"></script>
<![endif]-->
  <script type="text/javascript" src="static/vis.js"></script>
  <script type="text/javascript" src="static/reconnecting-websocket.min.js"></script>
</head>

<body onresize="graph.redraw();" >
<div id="mygraph"></div>
<div id="control"><button type="button"  onclick="acturator_menbrane_view=!acturator_menbrane_view">Actuator/Membrane View</button></div>
<script type="text/javascript">
	var graph = null;
	var data = new vis.DataSet();
	data.add({x:1,y:1,z:1});
	acturator_menbrane_view=true;
	var options = {
		width:  "100%",
		height:  "100%",
		style: 'surface',
		showPerspective: true,
		showGrid: true,
		showShadow: false,
		xMax:50,
		xMin:0,
		yMax:50,
		yMin:0,
		zMax:25,
		zMin:-25,
		keepAspectRatio: true,
		verticalRatio: 0.2
	  };
	  var container = document.getElementById('mygraph');
	  graph = new vis.Graph3d(container, data, options);

function tl_mirror_map(input){
	var hexmap_x=25;
	var hexmap_y=25;
	var data = new vis.DataSet();
	var test=[];
	for (var x=-hexmap_x;x<=hexmap_x;x++){
		for (var y=-hexmap_y;y<=hexmap_y;y++){
			var r=Math.sqrt(x*x+y*y);
			r=r/hexmap_x;
			var theta=Math.atan2(y, x)  / (2.0*Math.PI)+0.5;
			var ring=0;
			if (Math.floor(r*10)<9) {
				 ring=24+Math.ceil(theta*16);
			}
			if (Math.floor(r*10)<6) {
				 ring=8+Math.ceil(theta*16);
			}
			if (Math.floor(r*10)<3){
				 ring=0+Math.ceil(theta*8);
			}
			if (ring>40 || ring<0){
				//console.log(ring)
			}
			test[(x+hexmap_x)+(y+hexmap_y)*(hexmap_x*2)]=input[ring];
		}
	}
	// smooth filter
	var smooth_l=4;
	for (var x=0;x<2*hexmap_x;x++) 
		for (var y=0;y<2*hexmap_y;y++) {
			//get center
			var xfix=x-hexmap_x+smooth_l/2;
			var yfix=y-hexmap_y+smooth_l/2;
			var r=Math.sqrt(xfix*xfix+yfix*yfix);
			var holding_radius=hexmap_x*9/10;
			var R=200; 
			if (acturator_menbrane_view){
				//smooth 
				var sum=0;
				for (var sx=0;sx<smooth_l;sx++) 
					for (var sy=0;sy<smooth_l;sy++) 
						sum+=test[(y+sy)*(hexmap_x*2)+x+sx];
				sum/=smooth_l*smooth_l;
				//hemi-sphere correction
				var height=Math.sqrt(R*R-r*r)-Math.sqrt(R*R-holding_radius*holding_radius);
				var height_r0= Math.sqrt(R*R)-Math.sqrt(R*R-holding_radius*holding_radius);
				var corrected = sum-input[0];
				corrected=corrected*(height/height_r0)+input[0];
			}else{
				var corrected = test[(y+smooth_l/2)*(hexmap_x*2)+x+smooth_l/2];
			}
			//surface holder correction
			var z1=input[41];var x1=holding_radius*Math.sin(Math.PI*0+Math.PI*1/2+Math.PI);var y1=holding_radius*Math.cos(Math.PI*0+Math.PI*1/2+Math.PI);
			var z2=input[42];var x3=holding_radius*Math.sin(Math.PI*2/3+Math.PI*1/2+Math.PI);var y3=holding_radius*Math.cos(Math.PI*2/3+Math.PI*1/2+Math.PI);
			var z3=input[43];var x2=holding_radius*Math.sin(-Math.PI*2/3+Math.PI*1/2+Math.PI);var y2=holding_radius*Math.cos(-Math.PI*2/3+Math.PI*1/2+Math.PI);
			var zfix=(x3*y2*z1 - xfix*y2*z1 - x2*y3*z1 + xfix*y3*z1 + x2*yfix*z1 - x3*yfix*z1 - x3*y1*z2 + xfix*y1*z2 +  x1*y3*z2 - xfix*y3*z2 - x1*yfix*z2 + x3*yfix*z2 + x2*y1*z3 - xfix*y1*z3 - x1*y2*z3 + xfix*y2*z3 + x1*yfix*z3 - x2*yfix*z3)/(x2*y1 - x3*y1 - x1*y2 + x3*y2 + x1*y3 - x2*y3);
			corrected+=(zfix)*1/3;
			corrected-=25;
			//aperature cut 
			if (r<=holding_radius)
				data.add({x:x,y:y,z:corrected})
		}
		return data;
	}

oko_responses=[]
function load_oko_responses(){
	JSZipUtils.getBinaryContent('static/oko.zip', function(err, data) {
    if(err) {
    	alert("Can not load oko response file.");
        throw err; // or handle err
    }
	JSZip.loadAsync(data).then(function (zip) {
	         for (let each in zip.files){
	         	zip.file(each).async("string").then(function (json_content) {
	    			actid = parseInt(each);
	    			console.log(actid)
	    			oko_responses[actid]=JSON.parse(json_content);
				});
	         }
    	});
	});
}
load_oko_responses();
function oko_mirror_map(input) {
	var data = new vis.DataSet();
	if (acturator_menbrane_view){
		for (var x=0;x<201;x+=3) 
			for (var y=0;y<201;y+=3) {
    			var sum =0;
				for (var act=0; act<=37;act++){
					if(oko_responses[act]==undefined) {
						return data;
					}else{
						sum+=oko_responses[act][x][y]*input[act]*5.2e6;
					}
				}
				//get center
				var xfix=x-100;
				var yfix=y-100;
				var r=Math.sqrt(xfix*xfix+yfix*yfix);
				if (r<=100)
					data.add({x:x/4,y:y/4,z:sum+20})
			}
		return data;
	}else{
		var hexmap_x=9;
		var hexmap_y=9;
		var hexmap_orig = [
					0, 0, 0, 0, 0, 0, 0, 0,0,
					0, 0,23,24,25,26, 0, 0,0,
					0, 0,22,10,11,12,27, 0,0,
					0,21,09,03,04,13,28, 0,0,
					0,20,08,02,01,05,14,29,0,
					0,37,19,07,06,15,30, 0,0,
					0, 0,36,18,17,16,31, 0,0,
					0, 0,35,34,33,32, 0, 0,0,
					0, 0, 0, 0, 0, 0, 0, 0,0,
		];
		var hexmap=[];
		for (var i=0; i<hexmap_x*hexmap_y; i++){
			hexmap.push((1-input[hexmap_orig[i]])*40
				)
		}
		var test=[];
	   
		for (var y=0;y<hexmap_y;y++){
		   var length =6;
			var line =[];
			//padding
			if (y%2==1)
				for (var l=0;l<length/2;l++) 
					line.push((1-input[0])*40);
			for (var x=0;x<hexmap_x;x++)
				for (var l=0;l<length;l++) 
					line.push(hexmap[y*hexmap_x+x]);
			//padding
			if (y%2==0)
				for (var l=0;l<length/2;l++) 
					line.push((1-input[0])*40);
			// expand line
			for (var l=0;l<length;l++)
				for (var i=0;i<hexmap_x*length;i++) 
					test.push(line[i]);
		}
		var smooth_l=6;
		for (var x=0;x<length*hexmap_x;x++) 
			for (var y=0;y<length*hexmap_y;y++) {
				//get center
				var xfix=x-length*hexmap_x/2+smooth_l/2;
				var yfix=y-length*hexmap_y/2+smooth_l/2;
				var r=Math.sqrt(xfix*xfix+yfix*yfix);
				var holding_radius=length*hexmap_x/2*9/10;
				var corrected=test[(y+smooth_l/2)*(hexmap_x*length)+x+smooth_l/2];
				corrected-=22;
				if (r<=holding_radius)
					data.add({x:x,y:y,z:corrected})
		}
		return data;
	}
}
	
	function GetRequest() {  
	   var url = location.search;
	   var theRequest = new Object(); 
	   if (url.indexOf("?") != -1) { 
		  var str = url.substr(1); 
		  strs = str.split("&");  
		  for(var i = 0; i < strs.length; i ++) {  
			 theRequest[strs[i].split("=")[0]]=unescape(strs[i].split("=")[1]);
			}  
		}  
		return theRequest;  
	}
	//get server URL
	var req = GetRequest();
	if (req["server"]){
		var server = req["server"];
	}else{
		var server = "ws://127.0.0.1:8887/";
	}

	//websocket
	var ws = new ReconnectingWebSocket(server);
	function autoupdate_handler(){
		ws.send("update");
	};
	ws.onopen=function (event){
		autoupdate_timer=setTimeout(autoupdate_handler, 500);
	}
	ws.onmessage = function (event) {
		//clearTimeout(autoupdate_timer);
		var ret=JSON.parse(event.data);
		
			if (ret.length<40){
				graph.setData(oko_mirror_map(ret));
			}else{
				graph.setData(tl_mirror_map(ret));
			}
		
		autoupdate_timer=setTimeout(autoupdate_handler, 500);
	};
	ws.onclose=function(event){
		var data = new vis.DataSet();
		data.add({x:1,y:1,z:1});
		graph.setData(data);
	}

</script>
</body>
</html>

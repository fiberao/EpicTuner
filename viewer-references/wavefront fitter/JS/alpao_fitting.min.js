ALPAO_FITTING = function() {
    var a, d, e, f;
    var t, h, q, p, i;
    var g, m = new Array();
    var b = [20 / 79.99, 20 / 79.99, 5 / 17.89, 5 / 24.99, 5 / 24.48, 5 / 31.14, 5 / 31.14, 5 / 29.58, 5 / 29.58, 5 / 19.1, 5 / 34.67, 5 / 36.14, 5 / 32.23, 5 / 32.84];
    for (var l = 0; l < 14; l++) {
        m.push(0);
        newrms = $("<input>");
        newrms.attr("type", "text");
        newrms.attr("id", "nollrms" + l);
        newrms.attr("value", l == 1 ? 6 : 0);
        td = $("<td></td>");
        td.append(newrms);
        $("#ZERN_RMS").append(td);
        newp2v = $("<input>");
        newp2v.attr("type", "text");
        newp2v.attr("id", "nollp2v" + l);
        newp2v.attr("value", l == 1 ? 24 : 0);
        td = $("<td></td>");
        td.append(newp2v);
        $("#ZERN_P2V").append(td);
        slide = $("<span></span>");
        slide.style = "height:100px; margin:10px";
        td = $("<td></td>");
        td.append(slide);
        slide.attr("id", l);
        slide.slider({
            value: l == 1 ? (m[l] = 6) : 0,
            min: l < 2 ? -20 : -5,
            max: l < 2 ? 20 : 5,
            step: 0.05,
            tooltip: false,
            orientation: "vertical",
            slide: function(v, w) {
                id = v.target.id;
                $("#nollrms" + id).val(w.value);
                p2v = Math.abs(w.value / b[id]);
                p2v = Math.floor(p2v * 100) / 100;
                $("#nollp2v" + id).val(p2v);
                m[id] = w.value;
                k()
            },
            stop: function(v, w) {
                s()
            }
        });
        $("#ZERN_NOLL").append(td);
        img = $("<img></img>");
        img.attr("src", "img/NOLL" + (l + 2) + ".png");
        img.attr("alt", "NOLL" + l);
        td = $("<td></td>");
        td.append(img);
        $("#ZERN_IMG").append(td)
    }
    $("#fittingQuality").slider({
        min: 0,
        max: 100,
        step: 2,
        value: 96,
        tooltip: true,
        orientation: "horizontal",
        slide: function(v, w) {
            $("#qPct").html((w.value).toString())
        },
        stop: function(v, w) {
            n(w.value);
            s()
        }
    });
    $("#savedataas").click(function(v) {
        v.preventDefault();
        var w = new Blob(['{\n "target":' + JSON.stringify(q) + ', \n "command":' + JSON.stringify(p) + ', \n "applied":' + JSON.stringify(i) + ', \n "nolls_zern":' + JSON.stringify(m) + ', \n "fitting_coeff":' + JSON.stringify($("#fittingQuality").slider("option", "value")) + ', \n "mirror":' + JSON.stringify($("#mirror").val()) + "\n}"], {
            type: "text/plain;charset=" + document.characterSet
        });
        saveAs(w, "data.json")
    });
    $("#reset").click(function(v) {
        v.preventDefault();
        $(":input[type='text']").val(0);
        $("#ZERN_NOLL span").each(function() {
            $(this).slider("value", 0)
        });
        for (index = 0; index < m.length; ++index) {
            m[index] = 0
        }
        k();
        s()
    });
    $("#prog").progressbar({
        value: 0,
        max: 100
    });
    //准备控制器控制律函数h，w是Fitting quality，h其实就是我们的Mj*Q^-1T
    function n(w) {
        r = Math.floor(t.nAct * w / 100) - 1;
        r = Math.max(0, r);
        r = Math.max(t.nAct - 1, r); //changed
        var y = numeric.dim(t.V);
        var v = numeric.dim(t.S);
        var x = numeric.dim(t.U);
        //console.log("U!")
        //console.log(x)
        //console.log("V!")
        //console.log(y)
        //console.log("S!")
        //console.log(v)
        //console.log("hahahahahah!!!")
        //console.log(numeric.dot(t.V, numeric.transpose(t.V)));
        V = numeric.getBlock(t.V, [0, 0], [y[0] - 1, r]);
        
        S = numeric.getBlock(t.S, [0, 0], [r, r]);
        U = numeric.transpose(numeric.getBlock(t.U, [0, 0], [x[0] - 1, r]));
        h = numeric.dot(numeric.dot(V, S), U);
        h = numeric.transpose(h)
        //console.log(numeric.dim(h))
    }
    $.ajaxSetup({
        contents: {
            comp: /comp/
        },
        converters: {
            "text comp": true,
            "comp text": function(v) {
                $("#prog").progressbar("option", "value", false);
                $(".progress-label").text("Unpacking...");
                return RawDeflate.inflate(v)
            }
        }
    });

    function c(v) {
        $.ajax({
            method: "GET",
            url: "data/" + v + ".json",
            dataType: "comp json",
            cache: true,
            dataFilter: function(w) {
                $("#prog").progressbar("option", "value", false);
                $(".progress-label").text("Loading...");
                return w
            },
            success: function(w) {
            	console.log(w)
                t = w;
                $("#prog").progressbar("option", "value", false);
                $(".progress-label").text("Processing...");
                q = new Array(t.wfsMask.x.length);
                p = new Array(t.dmMask.x.length);
                u();
                n($("#fittingQuality").slider("option", "value"));
                k();
                s();
                $("#prog").progressbar("option", "value", 100);
                $("#prog").hide()
            },
            error: function(x, w, y) {
                console.log(x, w, y);
                $("#prog").show();
                $("#prog").css("background", "#ff0000")
            },
            progress: function(x) {
                if (x.lengthComputable) {
                    var w = (x.loaded / x.total) * 100;
                    $("#prog").show();
                    $("#prog").progressbar("option", "value", w);
                    $(".progress-label").text("Downloading...")
                } else {
                    console.warn("Content Length not reported!")
                }
            }
        })
    }
    $("#mirror").change(function() {
        c($(this).val())
    });
    $("document").ready(o);

    function o() {
        var v = new google.visualization.DataTable();
        v.addColumn("number", "x");
        v.addColumn("number", "y");
        v.addColumn("number", "z");
        options = {
            width: "325px",
            height: "325px",
            style: "surface",
            showPerspective: false,
            showGrid: false,
            showShadow: false,
            keepAspectRatio: false,
            verticalRatio: 0.5,
            cameraPosition: {
                horizontal: Math.PI * 0.12,
                vertical: Math.PI * 0.25,
                distance: 1.5
            },
            backgroundColor: {
                strokeWidth: 0
            },
        };
        a = new links.Graph3d(document.getElementById("targetWF"));
        a.draw(v, options);
        e = new links.Graph3d(document.getElementById("appliedWF"));
        e.draw(v, options);
        options = {
            width: "325px",
            height: "325px",
            style: "surface",
            showZAxis: false,
            showPerspective: false,
            showGrid: false,
            showShadow: false,
            keepAspectRatio: false,
            verticalRatio: 0.15,
            cameraPosition: {
                horizontal: Math.PI * 0.12,
                vertical: Math.PI * 0.25,
                distance: 1.5
            },
            backgroundColor: {
                strokeWidth: 0
            },
        };
        f = new links.Graph3d(document.getElementById("differentialWF"));
        f.draw(v, options);
        options = {
            width: "325px",
            height: "325px",
            style: "box",
            showZAxis: false,
            showPerspective: false,
            showGrid: true,
            showShadow: false,
            keepAspectRatio: false,
            verticalRatio: 1,
            cameraPosition: {
                horizontal: 0,
                vertical: Math.PI * 0.5,
                distance: 1.5
            },
            backgroundColor: {
                strokeWidth: 0
            },
        };
        d = new links.Graph3d(document.getElementById("mirrorCM"), false);
        d.draw(v, options);
        c($("#mirror").val())
    }
    // 计算泽妮可到g
    function u() {
        nelem = t.wfsMask.x.length;
        g = new Array(nelem);
        for (var w = 0; w < nelem; w++) {
            var v = t.wfsMask.x[w];
            var z = t.wfsMask.y[w];
            g[w] = new Array(14);
            R = Math.sqrt(v * v + z * z);
            T = Math.atan2(z, v);
            g[w][0] = 2 * R * Math.cos(T);
            g[w][1] = 2 * R * Math.sin(T);
            g[w][2] = Math.sqrt(3) * (2 * R * R - 1);
            g[w][3] = Math.sqrt(6) * R * R * Math.sin(2 * T);
            g[w][4] = Math.sqrt(6) * R * R * Math.cos(2 * T);
            g[w][5] = Math.sqrt(8) * (3 * R * R * R - 2 * R) * Math.sin(T);
            g[w][6] = Math.sqrt(8) * (3 * R * R * R - 2 * R) * Math.cos(T);
            g[w][7] = Math.sqrt(8) * (R * R * R) * Math.sin(3 * T);
            g[w][8] = Math.sqrt(8) * (R * R * R) * Math.cos(3 * T);
            g[w][9] = Math.sqrt(5) * (6 * R * R * R * R - 6 * R * R + 1);
            g[w][10] = Math.sqrt(10) * (4 * R * R * R * R - 3 * R * R) * Math.cos(2 * T);
            g[w][11] = Math.sqrt(10) * (4 * R * R * R * R - 3 * R * R) * Math.sin(2 * T);
            g[w][12] = Math.sqrt(10) * R * R * R * R * Math.cos(4 * T);
            g[w][13] = Math.sqrt(10) * R * R * R * R * Math.sin(4 * T)
        }
    }
    // 根据滑块输入m，计算泽妮可幅度响应到q(B)，输出
    function k() {
        nelem = t.wfsMask.x.length;
        mean = 0;
        for (var z = 0; z < nelem; z++) {
            q[z] = 0;
            for (var w = 0; w < m.length; w++) {
                q[z] += m[w] * g[z][w]
            }
            mean += q[z]
        }
        mean /= nelem;
        var B = new google.visualization.DataTable();
        B.addColumn("number", "x");
        B.addColumn("number", "y");
        B.addColumn("number", "z");
        rms = 0;
        for (var z = 0; z < nelem; z++) {
            q[z] -= mean;
            var A = q[z];
            var v = t.wfsMask.x[z];
            var C = t.wfsMask.y[z];
            rms += A * A;
            B.addRow([v, C, A])
        }
        a.redraw(B);
        r = B.getColumnRange(2);
        p2v = Math.floor(Math.abs(r.min - r.max) * 100) / 100;
        rms = Math.sqrt(rms / B.getNumberOfRows());
        rms = Math.floor(rms * 100) / 100;
        $("#targetStat").html("P2V: " + p2v + "&micro;m")
    }
    // 根据q波前计算控制器电压p，根据控制器电压p计算i
    function s() {
        p = numeric.dot(q, h);
        i = numeric.dot(p, t.IF);
        numeric.largeArray = Infinity;
        numeric.precision = 17;
        //console.log(numeric.prettyPrint(h));
         console.log(numeric.prettyPrint(t.wfsMask.x));
          console.log(numeric.prettyPrint(t.wfsMask.y));
       // numeric.precision = 17;
        //console.log(numeric.prettyPrint(t.IF));
        //console.log(numeric.dot(t.IF,numeric.inv(numeric.dot(numeric.transpose(t.IF),t.IF))))
        //console.log(numeric.transpose(h));
        j()
    }

    function j() {
        var z = new google.visualization.DataTable();
        var C = new google.visualization.DataTable();
        var B = new google.visualization.DataTable();
        z.addColumn("number", "x");
        z.addColumn("number", "y");
        z.addColumn("number", "z");
        C.addColumn("number", "x");
        C.addColumn("number", "y");
        C.addColumn("number", "z");
        B.addColumn("number", "x");
        B.addColumn("number", "y");
        B.addColumn("number", "z");
        nelem = t.dmMask.x.length;
        for (var w = 0; w < nelem; w++) {
            var A = p[w];
            var v = t.dmMask.x[w];
            var E = t.dmMask.y[w];
            B.addRow([v, E, -A])
        }

        d.redraw(B);
        r = B.getColumnRange(2);
        min = Math.floor(r.min * 100) / 100;
        max = Math.floor(r.max * 100) / 100;
        pct = Math.floor((max - min) / 2 * 10000) / 100;
        $("#mirrorStat").html(pct + "%");
        if (pct >= 100) {
            $("#mirrorStat").css("color", "red")
        } else {
            $("#mirrorStat").css("color", "#346594")
        }
        rms = 0;
        nelem = t.wfsMask.x.length;
        //算输出电压的表面响应i
        for (var w = 0; w < nelem; w++) {
            var v = t.wfsMask.x[w];
            var E = t.wfsMask.y[w];
            var D = i[w];
            rms += D * D;
            z.addRow([v, E, D])
        }
        e.redraw(z);
        r = z.getColumnRange(2);
        p2v = Math.floor(Math.abs(r.min - r.max) * 100) / 100;
        rms = Math.sqrt(rms / nelem);
        rms = Math.floor(rms * 100) / 100;
        $("#appliedStat").html("P2V: " + p2v + "&micro;m");
        rms = 0;
        mean = 0;
        nelem = t.wfsMask.x.length;
        for (var w = 0; w < nelem; w++) {
            var v = t.wfsMask.x[w];
            var E = t.wfsMask.y[w];
            var D = q[w] - i[w];
            rms += D * D;
            mean += D;
            C.addRow([v, E, D])
        }
        mean /= nelem;
        rms = 0;
        for (var w = 0; w < nelem; w++) {
            D = q[w] - i[w] - mean;
            rms += D * D
        }
        f.redraw(C);
        r = C.getColumnRange(2);
        p2v = Math.abs(r.min - r.max);
        rms = Math.sqrt(rms / nelem);
        lambdaOn = Math.floor(1 / p2v * 100) / 100;
        if (t.dmMask.x.length == 88) {
            rms *= 1.3
        }
        rms = Math.floor(rms * 1000) / 1000;
        p2v = Math.floor(p2v * 100) / 100;
        $("#diffStat").html("RMS: " + rms + "&micro;m ")
    }
};